					PROIECT - POO TV



Descriere structura proiect: 

workflow -> package-ul in care am scris tot codul (excluzand Main)

----Main: aici am citit inputul folosindu-ma de biblioteca Jackson, care parseaza datele
citite din fisier direct in obiecte, daca clasele lor aceleasi campuri, gettere si settere
si un constructor default. Asadar, mi-am creat aceste clase, care se pot gasi in directorul
fileio (User, Movie, Filters, Credentials).
Cu datele deja parsate in obiecte, am instantiat un obiect din clasa Database si am executat
pe rand fiecare comanda. Dupa ce executia unei comenzi s-a incheiat, am luat output-ul
acesteia si l-am adaugat in array-ul final, array care tine toate raspunsurile si care va fi
printat la final. Am fost nevoit sa fac o copie a raspunsului, deoarece acesta isi schimba
state-ul la fiecare comanda.

----workflow/Database: Clasa de tip "manager", care tine cont de state-ul intregului flow de
operatii. Aici am lista de useri, de filme, userul curent, si output-ul ultimei operatii.

----workflow/fileio && io: Directoare cu clase in care am retinut informatii de la inputData.
Exceptand clasa 'Output' care are rolul de a retine informatiile care trebuiesc scrie in 
fisierul de out.


Pentru design pattern-ul cerut, am folosit Command. Acesta este format din:
----workflow/Invoker -> primeste comanda de la main, si o executa
----workflow/Command -> interfata comenzii
----workflow/command/OnPageCommand -> clasa concreta care implementeaza comanda on_page
----workflow/command/ChangePageCommand -> clasa concreta care implementeaza comanda change_page
Aceste comenzi le-am creat in Main, in functie de tipul comenzii de input, iar invoker-ul le
executa.

Pentru a ma folosi de "magia" POO-ului, am creat o interfata pentru pagina, deoarece nu am
vrut sa scriu codul pentru toate paginile intr-o singura clasa, ci fiecare pagina ar trebui
sa fie o clasa in sine, care implementeaza metodele interfetei Page in mod unic. Astfel,
putem adauga cu usurinta alte pagini, si chiar putem modifica functionalitatile uneia cu
usurinta. Paginile se gasesc in workflow/pages. Aici am implementat la fiecare dintre acestea 
comenzile on_page si change_page. Aceste clase actioneaza pe Database, si o modifica in functie 
de comanda.

Legat de JavaDoc pentru metode :

----workflow/pages/unauthenticated/RegisterPage

  public void registerError(final Database database) -> Metoda pentru cazul in care nu se poate 
realiza inregistrarea

  public void registerSuccess(final Database database, final Action action) -> Metoda care 
realizeaza inregistrarea unui nou utilizator si adaugarea lui in baza de date

  public void register(final Database database, final Action action) -> Metoda care verifica 
posbilitatea de inregistrare a unui nou utilizator



----workflow/pages/unauthenticated/LoginPage

  public void loginError(final Database database) -> Metoda care seteaza eroare in cazul in 
care nu se poate realiza logarea

  public void loginSuccess(final Database database, final User user) -> Metoda de realizare a 
logarii, setam pagina ca fiind cea de autentificare, index ului userului curent

   public void login(final Database database, final Credentials credentials) -> Metoda care 
verifica daca logarea este posibila



----workflow/pages/authenticated/MoviesPage

   private void searchMovies(final Database database, final String startsWith) -> Metoda 
pentru cautarea filmelor care incep cu un anume subsir

   public void seeDetails(final Database database, final Action action) -> Metoda pentru 
a vedea detaliile unui film

   public void filterMovies(final Database database, final Filters filters) -> Metoda 
pentru filtrarea filmelor dupa actori si/sau gen

   public void durationSort(final Database database, final Filters filters) -> Metoda 
de sortare dupa durata

   public void ratingSort(final Database database, final Filters filters) -> Metoda de 
sortare dupa rating



----workflow/pages/authenticated/SeeDetailsPage

   public void purchase() ->  Metoda care verifica daca cumva filmul este cumparat, 
in caz contrar daca utilizatorul este unul premium sau standard

   public void premiumUserPurchase() -> Metoda de cumparare adresata utilizatorilor 
care detin un cont premium
   
   public void standardUserPurchase() -> Metoda de achiztionare a unul film, adresata
unui utilizator standard

   public void watch() -> Metoda de a adauga un film in cele vizionate

   public void like() -> Metoda de apreciere a unui film vizionat

   private void rate(final int rate) -> Metoda de evaluare a unui film deja vizionat



----workflow/pages/authenticated/UpgradesPage

    public void buyPremiumAccount(final Database database) ->  Metoda pentru a cumpara 
cont premium

    public void buyTokens(final Database database, final Action action) -> Metoda pentru 
a schimba balance cu tokens

 Going forward To Etapa 2

--- Am inceput prin a implementa cele 2 comenzi noi (back, database) ale caror metode
abstracte apar in interfata 'Page' :  void backPage(Database database) /
void modifyDatabase(Database database, Action action)

Pentru a putea executa aceste metode prin Design Pattern am mai introdus 2 clase
(BackPageCommand && ModifyDatabaseCommand) in pachetul Command fiecare apeland metoda
pe pagina curenta.

Pentru feature-ul de back am ales sa fac un ArrayList<String> pages unde se retine pagina
anterioara. Acest ArrayList se initializeaza in momentul in care utilizatorul curent se
delogheaza. Cand se primeste o comanda de tip back se scoate din ArrayList ultima pagina
si se schimba pagina.

Pentru modificarea bazei de date am creeat 2 metode simple addMovie, respectiv deleteMovie.

addMovie -> Adauga campului movies din clasa Database prin metoda add filmul primit ca
parametru.

deleteMovie -> Sterge filmul primit ca parametru din lista movies si eventual din
listele de filme cumparate/vizionate/apreciate/evaluate ale utilizatorilor din baza de date.

Si ... cam atat :) 


Ciupitu Andi Mihai 
321 CD 
